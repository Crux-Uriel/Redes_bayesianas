---
title: "Redes_b_html"
author: "Uriel"
date: "2025-07-16"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r redes, message=FALSE, warning=FALSE}
#CARGA DE LIBRERIAS
library(corrplot)
library(bnlearn)
library(visNetwork)
library(RCurl)
library(gRbase)
library(gRain)

#Se carga libreria para carga de datos desde github
library(RCurl)



#Carga de la base de datos
url<-"https://raw.githubusercontent.com/Crux-Uriel/Redes_bayesianas/refs/heads/main/diabetes.csv"
url_csv<-getURL(url)
datos<-read.csv(text=url_csv,header = F)
#nombres de las variables
names(datos)<-c("Embarazo",
                "Glucosa",
                "Presion",
                "Tricep",
                "Insulina",
                "IMC",
                "Pedigree",
                "Edad",
                "Diabetes")
attach(datos)

#Análisis exploratorio
#summary(datos[,1])
#sort(unique(datos[,1]))
#hist(datos[,1])

#summary(datos[,2])
#sort(unique(datos[,2]))

#NA'S
datos.limp<-datos
datos.limp[(which(Glucosa==0)),2]=NA
datos.limp[(which(Presion==0)),3]=NA
datos.limp[(which(Tricep==0)),4]=NA
datos.limp[(which(Insulina==0)),5]=NA
datos.limp[(which(IMC==0)),6]=NA


#Categorización.
#Embarazos
datos.limp[(which(datos.limp[,1]<=1)),1]=0
datos.limp[(which(datos.limp[,1]>1 & datos.limp[,1]<=4)),1]=1
datos.limp[(which(datos.limp[,1]>4)),1]=2

#Glucosa
datos.limp[(which(datos.limp[,2]<140)),2]=0
#datos.limp[(which(datos.limp[,2]>70 & datos.limp[,2]<140)),2]=1
datos.limp[(which(datos.limp[,2]>=140)),2]=1

#Presion
datos.limp[(which(datos.limp[,3]<=60)),3]=0
datos.limp[(which(datos.limp[,3]>60 & datos.limp[,3]<90)),3]=1
datos.limp[(which(datos.limp[,3]>=90)),3]=2

#Tricep
datos.limp[(which(datos.limp[,4]<=25)),4]=0
datos.limp[(which(datos.limp[,4]>25)),4]=1

#Insulina
datos.limp[(which(datos.limp[,5]<=120)),5]=0
datos.limp[(which(datos.limp[,5]>120)),5]=1

#IMC
datos.limp[(which(datos.limp[,6]<=25)),6]=0
datos.limp[(which(datos.limp[,6]>25 & datos.limp[,6]<=30)),6]=1
datos.limp[(which(datos.limp[,6]>30)),6]=2

#Pedigree
datos.limp[(which(datos.limp[,7]>quantile(Pedigree,.75))),7]=3
datos.limp[(which(datos.limp[,7]>quantile(Pedigree,.5) &
                    datos.limp[,7]<=quantile(Pedigree,.75))),7]=2
datos.limp[(which(datos.limp[,7]>quantile(Pedigree,.25) &
                    datos.limp[,7]<=quantile(Pedigree,.5))),7]=1
datos.limp[(which(datos.limp[,7]<=quantile(Pedigree,.25))),7]=0

#Edad
datos.limp[(which(datos.limp[,8]<=41)),8]=0
#datos.limp[(which(datos.limp[,8]>41 & datos.limp[,8]<=61)),8]=1
datos.limp[(which(datos.limp[,8]>41)),8]=1

#Correlación
correlacion<-cor(as.matrix(datos.limp),use = "pairwise.complete.obs")
corrplot.mixed(correlacion, upper="square",lower="number")

#D como el conjunto de datos
D<-datos.limp
#como factores
D[names(datos)]<-lapply(D[names(datos)],as.factor)
sapply(D, class)

#Conjunto de entrenamiento de prueba 
set.seed(27)
muestra <- sample(1:nrow(D), size = 614)
D.train <- D[muestra,]
D.test <- D[-muestra,]

nrow(D.train); nrow(D.test)


#Aprendizaje estructural
#Generacion de un modelo a través de la 
#muestra de entrenamiento

#Funcion para plotear redes:
plot.network <- function(structure, ht = "400px",title,subtitle){
  nodes.uniq <- unique(c(structure$arcs[,1], structure$arcs[,2]))
  nodes <- data.frame(id = nodes.uniq,
                      label = nodes.uniq,
                      color = "darkturquoise",
                      shadow = TRUE,
                      shape="circle")
  
  edges <- data.frame(from = structure$arcs[,1],
                      to = structure$arcs[,2],
                      arrows = "to",
                      smooth = TRUE,
                      shadow = TRUE,
                      color = "black")
  
  return(visNetwork(nodes, edges, height = ht, width = "100%",main=title,submain=subtitle
  ) %>% visLayout(randomSeed = 27) 
  )
}

#RB sin ninguna restricción
RB.sinrest<-structural.em(D.train,return.all = TRUE,maximize.args = list(restart=100))
plot.network(RB.sinrest$dag,title = "",subtitle = "")

#funcion para fuerza de los arcos
fuerza.bootsrap<-function(RB,args=list()){
  arcs = boot.strength(RB$imputed, algorithm = "hc",algorithm.args = args)
  print(arcs[(arcs$strength > 0.5) & (arcs$direction >= 0.5), ])
  #prueba<-(averaged.network(arcs,threshold = .5))
  return(arcs)
}
boot.RB.sinrestricciones<-fuerza.bootsrap(RB.sinrest)
boot.RB.sinrestricciones[which(boot.RB.sinrestricciones$from=="Diabetes"),
]


#RED CON RESTRICCIONES
## ARCOS PROHIBIDOS:
blacklist<-data.frame(from=names(D)[-8],to=rep("Edad",8))
whitelist4=data.frame(from=c("IMC","Glucosa","Pedigree","IMC","Embarazo"),
                      to=c("Diabetes","Diabetes","Diabetes","Tricep","Tricep"))
RB.b1w4<-structural.em(D.train,
                       maximize.args = list(blacklist=blacklist,restart=100,whitelist=whitelist4),
                       return.all = TRUE)
plot.network(RB.b1w4$dag,title = "",subtitle = "")
#bootsrap:
boot.RB.b1w4<-fuerza.bootsrap(RB.b1w4,list(whitelist=whitelist4,blacklist=blacklist))


#Tablas de probabilidad condicionada:
RB.b1w4$fitted$Pedigree
RB.b1w4$fitted$Edad
RB.b1w4$fitted$Presion
RB.b1w4$fitted$Embarazo
RB.b1w4$fitted$Glucosa
RB.b1w4$fitted$IMC
RB.b1w4$fitted$Tricep
RB.b1w4$fitted$Insulina
RB.b1w4$fitted$Diabetes

#Redes como grain
gr.RB1<-as.grain(RB.sinrest$fitted)
gr.RB10<-as.grain(RB.b1w4$fitted)

#redes a probar
redes<-list(gr.RB1,gr.RB10)
#Funcion de propagacion
prop<-function(red){
  propagacion=red
  prediccion.train<-predict(propagacion,response = "Diabetes",newdata = D.train,predictors = names(D)[-9],type="distribution")
  pred.train<-as.integer(prediccion.train$pred$Diabetes)
  ac.train<-sum(Diab.train==pred.train)/nrow(D.train)
  
  prediccion.test<-predict(propagacion,response = "Diabetes",newdata = D.test,predictors = names(D)[-9],type="distribution")
  pred.test<-as.integer(prediccion.test$pred$Diabetes)
  ac.test<-sum(Diab.test==pred.test)/nrow(D.test)
  return(list(prediccion.train$pred$Diabetes,prediccion.test$pred$Diabetes))
}
# Crear variables necesarias para la función prop
Diab.train <- as.integer(as.character(D.train$Diabetes))
Diab.test <- as.integer(as.character(D.test$Diabetes))

ACC.PRU<-lapply(redes, prop)

#Probabilidades 
ACC.PRU[[2]][1]



```

<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Precisión del Modelo</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    
    canvas {
      max-width: 100%;
    }
  </style>
</head>
<body>
  <h3>Precisión del Modelo</h3>
  <p><strong>Precisión = 454 / 614 = 0.7394 (73.94%)</strong><br>
  Esto significa que el modelo clasificó correctamente a 454 pacientes de 614, lo cual indica un buen desempeño para este problema de clasificación binaria.</p>

  <canvas id="precisionChart" width="400" height="400"></canvas>

  <script>
    const datos = {
      labels: ["Clasificados Correctamente (454)", "Clasificados Incorrectamente (160)"],
      datasets: [{
        data: [454, 160],
        backgroundColor: ["#4CAF50", "#F44336"]
      }]
    };

    new Chart(document.getElementById("precisionChart"), {
      type: 'pie',
      data: datos,
      options: {
        plugins: {
          legend: {
            position: 'bottom'
          },
          tooltip: {
            callbacks: {
              label: function(context) {
                const total = 454 + 160;
                const valor = context.parsed;
                const porcentaje = (valor / total * 100).toFixed(2);
                return `${context.label}: ${valor} (${porcentaje}%)`;
              }
            }
          }
        }
      }
    });
  </script>
</body>
</html>













